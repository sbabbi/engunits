/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <algorithm>
#include <iomanip>
#include <iostream>
#include <engineering_units/si.hpp>
#include <engineering_units/io.hpp>

namespace si = engunits::si;
using namespace si::literals;
using engunits::quantity_cast;

class isa_atmosphere
{
public:
    
    template<class T, class ... Ts>
    using quantity = engunits::quantity<T, Ts...>;
    
    using lapse_rate_t = quantity< double, 
                                   si::kelvin,
                                   si::meter_<-1> >;

    using pressure_t = quantity< double,
                                 si::hectopascal >;
    
    using temperature_t = quantity< double,
                                    si::kelvin >;

    using density_t = quantity< double, 
                                si::kilogram,
                                si::meter_<-3> >;
    
    using altitude_t = quantity< double, si::meter >;
    
    struct result
    {
        pressure_t pressure;
        density_t density;
        temperature_t temperature;
    };
    
    explicit isa_atmosphere( pressure_t psl = pressure_t(1.0_atm),
                             temperature_t tsl = temperature_t( 15.0_C - si::abs_zero ),
                             lapse_rate_t lapse_rate = lapse_rate_t( -6.5 * si::kelvin() * si::kilometer_<-1>() ) ) :
        pressure_sl_( psl ),
        temperature_sl_( tsl ),
        lapse_rate_( lapse_rate )
    {}
    
    result operator()( altitude_t const & h ) const
    {
        using engunits::second_;

        // Dry-air gas constant
        constexpr auto R = 287.058 * si::joule() * si::kilogram_<-1>() * si::kelvin_<-1>();
        
        constexpr auto g = 9.81 * si::meter() * second_<-2>();
        
        // Clamp the altitude to the tropopause limit
        const auto h_lim = std::min(h, 11000.0_m);
        
        // Compute temperature
        const auto T_lim = temperature_sl_ + lapse_rate_ * h_lim;
        
        // Temperature exponent
        const double k = -(g / R) / lapse_rate_;

        // Compute pressure
        const auto p_lim = pressure_sl_ * std::pow( T_lim / temperature_sl_,
                                                    k );
        const auto rho_lim = density_t( p_lim / ( T_lim *R ) );

        if ( h < 11000.0_m )
        {
            // We are done
            return result{ pressure_t(p_lim), rho_lim, T_lim };
        }
        
        // Inside tropopause
        const auto rho = rho_lim * std::exp( - (g / R) * ( h - h_lim ) / T_lim );
        
        const auto p = pressure_t( rho * R * T_lim );
        
        return result{ p, rho, T_lim };
    }
    
    
private:    
    quantity< double,
              si::megapascal >  pressure_sl_;
    
    quantity< double,
              si::kelvin >      temperature_sl_;
    
    lapse_rate_t lapse_rate_;
};

int main()
{
    isa_atmosphere atm;
    
    for ( auto h = 0.0_m; h < 20000.0_m; h += 1000.0_m )
    {
        auto a = atm(h);
        std::cout << std::left << std::setw(10) << h 
                  << std::setw(12) << a.pressure
                  << std::setw(12) << (a.temperature + si::abs_zero) << std::endl;
    }
    
    return 0;
}
