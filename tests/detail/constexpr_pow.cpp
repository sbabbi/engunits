/**
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <ratio>
#include <engineering_units/detail/constexpr_pow.hpp>

#include <iostream>

using engunits::detail::constexpr_pow;

// note: for the integer exponent case, we aim to provide the exact result when casted to double.
// most of these tests are broken on MSVC, 
// because long double is just an alias for double

void test_positive_base_positive_integer_exponent()
{
    static_assert(
        constexpr_pow(1.0L, 1 ) == 1.0L,
        "1^1 = 1" );
    
    static_assert(
        constexpr_pow(2.0L, 1 ) == 2.0L,
        "2^1 = 1" );
    
    static_assert(
        constexpr_pow(1.0L, 2 ) == 1.0L,
        "1^2 = 1" );
    
    static_assert(
        constexpr_pow(1.0L, 0 ) == 1.0L,
        "1^0 = 1" );
    
    static_assert(
        constexpr_pow(2.0L, 1 ) == 2.0L,
        "2^1 = 1" );
    
    static_assert(
        constexpr_pow(2.0L, 4 ) == 16.0L,
        "2^4 = 16 " );
    
    static_assert(
        constexpr_pow(2.0L, 32 ) == 4294967296.0L,
        "2^32 = 4294967296" );
    
    static_assert(
        constexpr_pow(4.0L, 16 ) == 4294967296.0L,
        "4^16 = 4294967296" );
    
    static_assert(
        constexpr_pow(3.0L, 23 ) == 94143178827.0L,
        "2^23 = 94143178827" );
    
    static_assert(
        constexpr_pow(0.25L, 4 ) == 0.00390625L,
        "0.25^4 = 0.00390625" );

    // Note: larger results might not be very consistent across multiple compilers
    
    static_assert(
        constexpr_pow(0.0, 0) == 1.0L,
        "0^0 = 1" ); // technically undefined, we return 1.
}

void test_negative_base_positive_integer_exponent()
{
    static_assert(
        constexpr_pow(-1.0L, 1) == -1.0L,
        "-1^1 == -1");
    
    static_assert(
        constexpr_pow(-1.0L, 2) == 1.0L,
        "-1^2 == 1");
    
    static_assert(
        constexpr_pow(-1.0L, 5) == -1.0L,
        "-1^5 == -1");
    
    static_assert(
        constexpr_pow(-2.0L, 31 ) == -2147483648.0L,
        "(-2)^31 = -2147483648" );
}

void test_negative_integer_exponent()
{
    static_assert(
        constexpr_pow( 1.0L, -1) == 1.0L,
        "1^-1 == 1");
    
    static_assert(
        constexpr_pow( 2.0L, -1) == 0.5L,
        "2^-1 == 0.5");
    
    static_assert(
        constexpr_pow( 2.0L, -4) == 0.0625L,
        "2^-4 == 0.0625");

     static_assert(
        constexpr_pow( -2.0L, -4) == 0.0625L,
        "(-2)^-4 == 0.0625");
       
    static_assert(
        constexpr_pow( 0.0625L, -4) == 65536.0L,
        "(0.0625)^-4 == 65536");
    
    static_assert(
        double(constexpr_pow(-10.0L, -4)) == 0.0001,
        "(-10)^(4) = 0.0001" );

    static_assert(
        constexpr_pow( 3.0L, -1) == 0.33333333333333333333L,
        "(3)^-1 == 1/3");

    static_assert(
        double(constexpr_pow(3.0L, -7)) == 4.57247370827617741198E-4,
        "3^(-7) = 0.00045724737" );
}

constexpr bool near_equal( long double x, long double y, long double toll )
{
    return (x > y ? y - x : x - y) < toll;
}

//note: for rational exponents, we are happy with reasonable approximations.
// also we are happy with compile-time error due to inf/nan, far better
// than allowing an unacceptable result to pass by.
void test_rational_exponent()
{
    static_assert(
        constexpr_pow( 1.0L, 1, 2) == 1.0L,
        "1^(1/2) == 1");
    
    static_assert(
        near_equal(constexpr_pow( 0.0L, 1, 10),
                   0.0,
                   1e-40 ),
        "0^(1/10) == 0");
    
    static_assert(
        double(constexpr_pow( 0.0L, 0, 10)) == 1.0,
        "0^(0/10) == 1");
    
    static_assert(
        near_equal(constexpr_pow( 2.0L, 0, 2),
                   1.4142135623730950488016887,
                   1e-9 ),
        "2^(1/2) == sqrt(2)");
    
    static_assert(
        near_equal(constexpr_pow( 1.3L, 149, 139 ),
                   1.3247707047,
                   0.0000000001),
        "5^(149/139) == 5.61378293703" );
    
    static_assert(
        constexpr_pow( 49.0L, 7, 2 ) == 823543.0L,
        "49^(7/2) == 823543.0L" );
    
    static_assert(
        near_equal( constexpr_pow( 17.0L, 15, 4 ),
                    41132.3436125,
                        0.0000001 ),
        "17^(15/4) == 41132.3436125" );
}

int main()
{
    test_positive_base_positive_integer_exponent();
    test_negative_base_positive_integer_exponent();
    test_negative_integer_exponent();
    test_rational_exponent();
}
