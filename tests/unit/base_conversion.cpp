/**
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <engineering_units/unit/base_conversion.hpp>

#include <engineering_units/si/length.hpp>
#include <engineering_units/imperial/length.hpp>

void test_convert_base_unit()
{
    using engunits::detail::convert_base_unit;
    namespace si = engunits::si;
    namespace imperial = engunits::imperial;
        
    static_assert( convert_base_unit(si::meter(), si::meter() ) == 1.0L,
                   "meter to meter = 1.0 " );
    
    static_assert( convert_base_unit(imperial::feet(), si::meter() ) == 0.3048L,
                   "feet to meter = 0.3048L " );
    
    static_assert( convert_base_unit(si::meter(), imperial::feet() ) == 
                   (1.0L / 0.3048L),
                   "meter to feet = 1.0 / 3048L " );
    
    static_assert( convert_base_unit(imperial::inch(), imperial::feet() ) == 
                    (1.0L / 12.0L),
                   "inch to feet = 1.0 / 12.0L" );
    
    static_assert( convert_base_unit(imperial::feet(), imperial::inch() ) == (12.0L),
                   "feet to inch = 12.0L" );
    
    static_assert( convert_base_unit(imperial::inch(), si::meter() ) == 
                   (1.0L/0.3048L) * 12.0L,
                   "inch to meter = (inch to feet) * (feet to meter) = "
                   "1.0 / 12.0L * 0.3048L" );
    
    static_assert( 
        double( convert_base_unit(imperial::inch(), si::millimeter() ) ) == 
        double( (1.0L / 12.0L) * (0.3048L) * 1000.0L) ,
        "inch to millimeter = (inch to feet) * (feet to meter) * (meter to millimeter) = "
        "(1.0 / 12.0L) * 0.3048L * 1000" );
    
    static_assert( 
        double( convert_base_unit(si::millimeter(), imperial::inch() ) ) == 
        double( 0.001L * (1.0L / 0.3048L) * 12.0L),
        "millimeter to inch = "
        "(millimeter to meter) * (meter to feet) * (feet to inch) = "
        "0.001L * (1.0L / 0.3048L) * 12.0L" );
}

void test_convert_base_unit_exp()
{
    using engunits::detail::convert_base_unit;
    namespace si = engunits::si;
    namespace imperial = engunits::imperial;
        
    static_assert( convert_base_unit(si::meter_<2>(), si::meter_<2>() ) == 1.0L,
                   "meter^2 to meter^2 = 1.0 " );
    
    static_assert( convert_base_unit(imperial::feet_<2>(), si::meter_<2>() ) == 
                   0.3048L * 0.3048L,
                   "feet to meter = 0.3048L * 0.3048L " );
    
    static_assert( convert_base_unit(si::meter_<3>(), imperial::feet_<3>() ) == 
                   (1.0L / 0.3048L) * (1.0L / 0.3048L) * (1.0L / 0.3048L),
                   "meter to feet = (1.0 / 3048L) ^3  " );
    
    static_assert( convert_base_unit(imperial::inch_<-1>(), imperial::feet_<-1>() ) == 
                   1.0L / (1.0L / 12.0L),
                   "inch^-1 to feet^-1 = 12.0L" );
    
    static_assert( 
        double( convert_base_unit(imperial::feet_<1,2>(), imperial::inch_<1,2>() ) *
                convert_base_unit(imperial::feet_<1,2>(), imperial::inch_<1,2>() ) ) == 
        double( 12.0L ),
        "(feet^(1/2) to inch^(1/2) )^2 = 12.0L" );
    
    static_assert( convert_base_unit(imperial::inch_<2>(), si::meter_<2>() ) == 
                   ((1.0L/0.3048L) * 12.0L) * ((1.0L/0.3048L) * 12.0L),
                   "inch^2 to meter^2 = ( (inch to feet) * (feet to meter) )^2 ="
                   "1.0 / 12.0L * 0.3048L" );
    
    static_assert( 
        double( convert_base_unit(imperial::inch_<2>(), si::millimeter_<2>() ) ) == 
        double( ( (1.0L / 12.0L) * (0.3048L) * 1000.0L) * 
                ( (1.0L / 12.0L) * (0.3048L) * 1000.0L) ),
        "inch^2 to millimeter^2 = "
        "((inch to feet) * (feet to meter) * (meter to millimeter))^2 = "
        "( (1.0 / 12.0L) * 0.3048L * 1000 )^2" );
    
    static_assert( 
        double( convert_base_unit(si::millimeter_<3>(), imperial::inch_<3>() ) ) == 
        double( (0.001L * (1.0L / 0.3048L) * 12.0L) *
                (0.001L * (1.0L / 0.3048L) * 12.0L) *
                (0.001L * (1.0L / 0.3048L) * 12.0L) ),
        "millimeter^3 to inch^3 = "
        "( (millimeter to meter) * (meter to feet) * (feet to inch) )^3 = "
        "( 0.001L * (1.0L / 0.3048L) * 12.0L)^3" );
}

int main() 
{
    test_convert_base_unit();
    test_convert_base_unit_exp();
}
