/**
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <engineering_units/si/length.hpp>
#include <engineering_units/si/time.hpp>
#include <engineering_units/si/mass.hpp>
#include <engineering_units/si/force.hpp>

#include <engineering_units/unit/multiply.hpp>

// using namespace can do fancy things with ADL, better test
// that things work the same with using namespace and with operator ::

#ifdef ENGUNITS_WITH_USING_NAMESPACE

using namespace engunits;
using namespace si;

#define TEST_ENGNS
#define TEST_SINS

#else

#define TEST_ENGNS engunits::
#define TEST_SINS  engunits::si::

#endif //ENGUNITS_WITH_USING_NAMESPACE

// since operator== is implemented in terms of operator*, it does not
// make much sense to use == for testing. Use this instead
template<class Lhs, class Rhs>
constexpr bool is_same(Lhs const &, Rhs const &)
{
    return std::is_same<Lhs, Rhs>::value;
}

void test_dimensionless()
{
    static_assert( ! TEST_ENGNS is_unit_v< TEST_ENGNS dimensionless>, 
                   "dimensionless is not an unit" );

    static_assert( 
        is_same( TEST_ENGNS dimensionless() * TEST_ENGNS dimensionless(),
                 TEST_ENGNS dimensionless() ),
        " dimensionless * dimensionless == dimensionless " );
    
    static_assert( 
        is_same( TEST_SINS meter() * TEST_ENGNS dimensionless(),
                 TEST_SINS meter() ),
        " meter * dimensionless == meter " );
    
    static_assert( 
        is_same( TEST_ENGNS dimensionless() * TEST_SINS meter(),
                 TEST_SINS meter() ),
        " dimensionless * meter == meter " );
    
    static_assert( 
        is_same( TEST_ENGNS dimensionless() * TEST_SINS meter() * TEST_ENGNS dimensionless(),
                 TEST_SINS meter() ),
        " dimensionless * meter * dimensionless == meter " );
    
    static_assert( 
        is_same( TEST_ENGNS dimensionless() * TEST_SINS newton() * TEST_ENGNS dimensionless(),
                 TEST_SINS newton() ),
        " dimensionless * newton * dimensionless == newton " );
    
    static_assert( 
        is_same( TEST_ENGNS dimensionless() * TEST_ENGNS mixed_unit<TEST_SINS meter, TEST_SINS second>(),
                 TEST_ENGNS mixed_unit<TEST_SINS meter, TEST_SINS second>() ),
        " dimensionless * (meter * second) == (meter * second)" );
    
    static_assert( 
        is_same( TEST_ENGNS mixed_unit<TEST_SINS meter, TEST_SINS second>() * TEST_ENGNS dimensionless(),
                 TEST_ENGNS mixed_unit<TEST_SINS meter, TEST_SINS second>() ),
        " (meter * second) * dimensionless == (meter * second)" );
}

void test_base()
{
    static_assert(
        is_same( TEST_SINS meter() * TEST_SINS meter_<-1>(),
                 TEST_ENGNS dimensionless() ),
                 " meter * meter^-1 == dimensionless"  );
    
    static_assert(
        is_same( TEST_SINS meter() * TEST_SINS meter_<2>(),
                 TEST_SINS meter_<3>() ),
                 " meter * meter^2 == meter^3" );
    
    static_assert(
        is_same( TEST_SINS meter() * TEST_SINS meter_<3,4>(),
                 TEST_SINS meter_<7,4>() ),
                 " meter * meter^(3/4) == meter^(7/4)" );
  
    static_assert(
        is_same( TEST_SINS newton() * TEST_SINS newton_<-1>(),
                 TEST_ENGNS dimensionless() ),
                 " newton * newton^-1 == dimensionless"  );
    
    static_assert(
        is_same( TEST_SINS newton() * TEST_SINS newton_<2>(),
                 TEST_SINS newton_<3>() ),
                 " newton * newton^2 == newton^3" );
    
    static_assert(
        is_same( TEST_SINS newton() * TEST_SINS newton_<3,4>(),
                 TEST_SINS newton_<7,4>() ),
                 " newton * newton^(3/4) == newton^(7/4)" );
}

void test_mixed()
{
    static_assert(
        is_same( TEST_SINS newton() * TEST_SINS meter(),
                  TEST_ENGNS mixed_unit< TEST_SINS newton, TEST_SINS meter >() ),
                 " newton * meter == <newton, meter> " );
    
    static_assert(
        is_same( TEST_SINS meter() * TEST_SINS newton(),
                  TEST_ENGNS mixed_unit< TEST_SINS meter, TEST_SINS newton >() ),
                 " meter * newton == <meter, newton> " );
    
    static_assert(
        is_same( TEST_SINS meter() * 
                 TEST_ENGNS mixed_unit< TEST_SINS meter_<-1>, TEST_SINS second >(),
                 TEST_SINS second() ),
                 " meter * <meter^-1, second> == second" );
    
    static_assert(
        is_same( TEST_SINS meter() * 
                 TEST_ENGNS mixed_unit< TEST_SINS kilogram, TEST_SINS second >(),
                 TEST_ENGNS mixed_unit< TEST_SINS meter, TEST_SINS kilogram, TEST_SINS second >() ),
                 " meter * <kilogram, second> == <meter, kilogram, second>" );
    
    static_assert(
        is_same( TEST_ENGNS mixed_unit< TEST_SINS kilogram, TEST_SINS second >() *
                 TEST_SINS meter(),
                 TEST_ENGNS mixed_unit< TEST_SINS kilogram, TEST_SINS second, TEST_SINS meter >() ),
                 " <kilogram, second> * meter == <kilogram, second, meter>" );
    
    static_assert(
        is_same( TEST_SINS meter() * 
                 TEST_ENGNS mixed_unit< TEST_SINS meter, TEST_SINS kilogram, TEST_SINS second >(),
                 TEST_ENGNS mixed_unit< TEST_SINS meter_<2>, TEST_SINS kilogram, TEST_SINS second >() ),
                 " meter * <meter, kilogram, second> == <meter^2, kilogram, second>" );
    
    static_assert(
        is_same( TEST_ENGNS mixed_unit< TEST_SINS meter, TEST_SINS kilogram, TEST_SINS second >() *
                 TEST_SINS second(),
                 TEST_ENGNS mixed_unit< TEST_SINS meter, TEST_SINS kilogram, TEST_SINS second_<2> >() ),
                 " <meter, kilogram, second> * second == <meter, kilogram, second<2>>" );

    static_assert(
        is_same( TEST_ENGNS mixed_unit< TEST_SINS meter, TEST_SINS second >() * 
                 TEST_ENGNS mixed_unit< TEST_SINS second_<-1>, TEST_SINS meter_<-1> >(),
                 TEST_ENGNS dimensionless() ),
                 " <meter, second> * <second^-1, meter^-1> == dimensionless" );
    
    static_assert(
        is_same( TEST_ENGNS mixed_unit< TEST_SINS meter, TEST_SINS kilogram, TEST_SINS second >() * 
                 TEST_ENGNS mixed_unit< TEST_SINS second_<-1>, TEST_SINS meter_<-1> >(),
                 TEST_SINS kilogram() ),
                 " <meter, kilogram, second> * <second^-1, meter^-1> == kilogram" );
    
    static_assert(
        is_same( TEST_ENGNS mixed_unit< TEST_SINS meter, TEST_SINS kilogram >() * 
                 TEST_ENGNS mixed_unit< TEST_SINS kilogram, TEST_SINS second_<-1>, TEST_SINS meter_<2> >(),
                 TEST_ENGNS mixed_unit< TEST_SINS meter_<3>, TEST_SINS kilogram_<2>, TEST_SINS second_<-1> >() ),
                 " <meter, kilogram> * <kilogram, second^-1, meter^2> == <meter^3, kilogram^2, second^-1> " );
}

int main()
{
    test_dimensionless();
    test_base();
    test_mixed();
}
