/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef ENGINEERING_UNITS_QUANTITY_HPP
#define ENGINEERING_UNITS_QUANTITY_HPP

#include <type_traits>
#include <utility>

#include <engineering_units/unit/traits.hpp>
#include <engineering_units/unit/mixed_unit.hpp>

#include <engineering_units/unit/conversion.hpp>
#include <engineering_units/unit/equality.hpp>
#include <engineering_units/unit/multiply.hpp>
#include <engineering_units/unit/pow.hpp>

#include <engineering_units/detail/doxygen.hpp>
#include <engineering_units/detail/fold_expressions.hpp>

namespace engunits
{

namespace detail
{

template<class ... Ts>
struct unit_type
{
    typedef mixed_unit<Ts...> type;
};

template<class T>
struct unit_type<T>
{
    typedef T type;
};

template<class ... Ts>
using unit_type_t = typename unit_type<Ts...>::type;

}

template<class T, class ... Units>
class quantity
{
public:
    /**
     * @brief The underlying type of this quantity
     */
    typedef T value_type;
    
    /**
     * @brief The unit type of this quantity
     * @sa Unit
     */
    typedef ENGUNITS_UNSPECIFIED(detail::unit_type_t<Units...>) unit_type;

private:
    template<class U, class ... OtherUnits>
    static constexpr bool allow_implicit_constructor =
        std::is_convertible<U, T>::value &&
        unit_type() == detail::unit_type_t<OtherUnits...>();

    template<class U, class ... OtherUnits>
    static constexpr bool allow_explicit_constructor =
        !std::is_convertible<U, T>::value &&
        std::is_constructible<T, U>::value &&
        unit_type() == detail::unit_type_t<OtherUnits...>();

    template<class U, class ... OtherUnits>
    static constexpr bool allow_converting_constructor =
        !allow_explicit_constructor<U, OtherUnits...> &&
        std::is_constructible<T, U>::value &&
        is_convertible_v<detail::unit_type_t<OtherUnits...>, unit_type >;

public:
    static_assert( sizeof ...( Units ) > 0, "Empty quantity not allowed" );
    static_assert( detail::all_of( is_unit_v<Units> ... ),
                   "quantity must be made of units" );

    /**
     * @brief Default constructor
     */
    constexpr quantity(
        ENGUNITS_ENABLE_IF( std::is_default_constructible<T>::value )
            ) noexcept( std::is_nothrow_default_constructible<T>::value ) = default;

    /**
     * @brief Copy construct from equivalent unit, and implicitly convertible @c value_type
     */
    template< class U, class ... OtherUnits >
    constexpr quantity(
        const quantity<U, OtherUnits ... > & other,
        ENGUNITS_ENABLE_IF( ( allow_implicit_constructor<const U &, OtherUnits ... > ) )
    ) noexcept( std::is_nothrow_constructible<T, U>::value ) :
        value_( other.value() )
    {}

    /**
     * @brief Copy construct from equivalent unit, and explicitly convertible @c value_type
     */
    template<class U, class ... OtherUnits >
    explicit constexpr quantity(
        const quantity<U, OtherUnits ... > & other,
        ENGUNITS_ENABLE_IF( ( allow_explicit_constructor<const U &, OtherUnits ... > ) )
    ) noexcept( std::is_nothrow_constructible<T, U>::value ) :
        value_( other.value() )
    {}

    /**
     * @brief Copy construct from a convertible unit and explicitly convertible @c value_type
     */
    template<class U, class ... OtherUnits >
    explicit constexpr quantity(
        const quantity<U, OtherUnits ... > & other,
        ENGUNITS_ENABLE_IF( ( allow_converting_constructor<const U &, OtherUnits ... > ) )
    ) noexcept( std::is_nothrow_constructible<T, U>::value ) :
        value_( other.value() * conversion_factor( other.unit(), unit() ) )
    {}
    
    /**
     * @brief Move construct from equivalent unit, and implicitly convertible @c value_type
     */
    template< class U, class ... OtherUnits >
    constexpr quantity(
        quantity<U, OtherUnits ... > && other,
        ENGUNITS_ENABLE_IF( ( allow_implicit_constructor<U&&, OtherUnits ... > ) )
    ) noexcept( std::is_nothrow_constructible<T, U>::value ) :
        value_( std::move(other.value()) )
    {}

    /**
     * @brief Move construct from equivalent unit, and explicitly convertible @c value_type
     */
    template<class U, class ... OtherUnits >
    explicit constexpr quantity(
        quantity<U, OtherUnits ... > && other,
        ENGUNITS_ENABLE_IF( ( allow_explicit_constructor<U&&, OtherUnits ... > ) )
    ) noexcept( std::is_nothrow_constructible<T, U>::value ) :
        value_( std::move(other.value()) )
    {}

    /**
     * @brief Move construct from a convertible unit and explicitly convertible @c value_type
     */
    template<class U, class ... OtherUnits >
    explicit constexpr quantity(
        quantity<U, OtherUnits ... > && other,
        ENGUNITS_ENABLE_IF( ( allow_converting_constructor<U&&, OtherUnits ... > ) )
    ) noexcept( std::is_nothrow_constructible<T, U>::value ) :
        value_( std::move(other.value()) * conversion_factor( other.unit(), unit() ) )
    {}
    
    constexpr quantity& operator=(const quantity & other)
        noexcept( std::is_nothrow_copy_assignable<T>::value )
    {
        value_ = other.value();
        return *this;
    }
    
    constexpr quantity& operator=(quantity && other)
        noexcept( std::is_nothrow_move_assignable<T>::value )
    {
        value_ = std::move(other.value());
        return *this;
    }
    
    /**
     * @brief Return a const reference to the underlying value.
     */
    constexpr const T & value() const &
    {
        return value_;
    }
    
    /**
     * @brief Return a reference to the underlying value.
     */
    constexpr T & value() &
    {
        return value_;
    }
    
    /**
     * @brief Return a rvalue-reference to the underlying value.
     */
    constexpr T&& value() &&
    {
        return std::move(value_);
    }

    /**
     * @brief Obtain an unit object for this quantity's unit.
     */
    static constexpr auto unit()
    {
        return unit_type {};
    }

private:
    T value_;
};

template<class T, class ... Us>
constexpr auto make_quantity( T && t, mixed_unit<Us...> const & )
{
    return quantity< std::remove_reference_t<T>, Us ... >( 
        std::forward<T>(t)
    );
}

template<class T, class U>
constexpr auto make_quantity( T && t, U const & )
{
    return quantity< std::remove_reference_t<T>, U >( 
        std::forward<T>(t)
    );
}

template<class Rhs,
         class ... RhsUnits>
constexpr auto operator+( const quantity<Rhs, RhsUnits ... > & rhs )
{
    return make_quantity( +rhs.value(), rhs.unit() );
}

template<class Rhs,
         class ... RhsUnits>
constexpr auto operator-( const quantity<Rhs, RhsUnits ... > & rhs )
{
    return make_quantity( -rhs.value(), rhs.unit() );
}

template<class Lhs,
         class Rhs,
         class ... LhsUnits,
         class ... RhsUnits>
constexpr auto operator+( const quantity<Lhs, LhsUnits ... > & lhs,
                          const quantity<Rhs, RhsUnits ... > & rhs )
{
    static_assert( lhs.unit() == rhs.unit(), "operator+ with different units" );
    
    return make_quantity( lhs.value() + rhs.value(), lhs.unit() );
}

template<class Lhs,
         class Rhs,
         class ... LhsUnits,
         class ... RhsUnits>
constexpr auto operator-( const quantity<Lhs, LhsUnits ... > & lhs,
                          const quantity<Rhs, RhsUnits ... > & rhs )
{
    static_assert( lhs.unit() == rhs.unit(), "operator- with different units" );
    
    return make_quantity( lhs.value() - rhs.value(), lhs.unit() );
}

template<class Lhs,
         class Rhs,
         class ... LhsUnits,
         class ... RhsUnits>
constexpr auto operator*( const quantity<Lhs, LhsUnits ... > & lhs,
                          const quantity<Rhs, RhsUnits ... > & rhs )
{    
    return make_quantity( lhs.value() * rhs.value(), lhs.unit() * rhs.unit() );
}

template<class Lhs,
         class Rhs,
         class ... LhsUnits,
         class ... RhsUnits>
constexpr auto operator/( const quantity<Lhs, LhsUnits ... > & lhs,
                          const quantity<Rhs, RhsUnits ... > & rhs )
{    
    return make_quantity( lhs.value() / rhs.value(), 
                          lhs.unit() * inverse(rhs.unit()) );
}

template<class Lhs,
         class Rhs,
         class ... LhsUnits,
         class ... RhsUnits>
constexpr auto operator==( const quantity<Lhs, LhsUnits ... > & lhs,
                           const quantity<Rhs, RhsUnits ... > & rhs )
{
    static_assert( lhs.unit() == rhs.unit(), "operator== with different units" );
    
    return lhs.value() == rhs.value();
}

template<class Lhs,
         class Rhs,
         class ... LhsUnits,
         class ... RhsUnits>
constexpr auto operator!=( const quantity<Lhs, LhsUnits ... > & lhs,
                           const quantity<Rhs, RhsUnits ... > & rhs )
{
    static_assert( lhs.unit() == rhs.unit(), "operator!= with different units" );
    
    return lhs.value() != rhs.value();
}

template<class Lhs,
         class Rhs,
         class ... LhsUnits,
         class ... RhsUnits>
constexpr auto operator<( const quantity<Lhs, LhsUnits ... > & lhs,
                          const quantity<Rhs, RhsUnits ... > & rhs )
{
    static_assert( lhs.unit() < rhs.unit(), "operator< with different units" );
    
    return lhs.value() < rhs.value();
}

template<class Lhs,
         class Rhs,
         class ... LhsUnits,
         class ... RhsUnits>
constexpr auto operator<=( const quantity<Lhs, LhsUnits ... > & lhs,
                           const quantity<Rhs, RhsUnits ... > & rhs )
{
    static_assert( lhs.unit() == rhs.unit(), "operator<= with different units" );
    
    return lhs.value() <= rhs.value();
}

template<class Lhs,
         class Rhs,
         class ... LhsUnits,
         class ... RhsUnits>
constexpr auto operator>( const quantity<Lhs, LhsUnits ... > & lhs,
                          const quantity<Rhs, RhsUnits ... > & rhs )
{
    static_assert( lhs.unit() == rhs.unit(), "operator> with different units" );
    
    return lhs.value() > rhs.value();
}

template<class Lhs,
         class Rhs,
         class ... LhsUnits,
         class ... RhsUnits>
constexpr auto operator>=( const quantity<Lhs, LhsUnits ... > & lhs,
                           const quantity<Rhs, RhsUnits ... > & rhs )
{
    static_assert( lhs.unit() == rhs.unit(), "operator>= with different units" );
    
    return lhs.value() >= rhs.value();
}

}

#endif //ENGINEERING_UNITS_QUANTITY_HPP
