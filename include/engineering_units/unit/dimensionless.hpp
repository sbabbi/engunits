/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef ENGINEERING_UNITS_UNIT_DIMENSIONLESS_HPP
#define ENGINEERING_UNITS_UNIT_DIMENSIONLESS_HPP

#include <engineering_units/unit/traits.hpp>
#include <engineering_units/detail/doxygen.hpp>

namespace engunits
{


/**
 * @brief Special empty type to represent dimensionless results
 */
struct dimensionless {};

/**
 * @brief Compare any unit to @c dimensionless, always false.
 * @relates dimensionless
 */
template<class Unit>
constexpr bool operator==(const Unit &, const dimensionless & )
{
    return false;
}

template<class Unit>
constexpr bool operator!=(const Unit &, const dimensionless & )
{
    return true;
}

/**
 * @brief @c dimensionless vs Unit comparison
 * @relates dimensionless
 */
template<class Unit>
constexpr bool operator==(const dimensionless &, const Unit & )
{
    return false;
}

template<class Rhs>
constexpr bool operator!=(const dimensionless &, const Rhs & )
{
    return true;
}

/**
 * @brief @c dimensionless vs @c dimensionless comparison, always true.
 * @relates dimensionless
 */
constexpr bool operator==(const dimensionless &, const dimensionless & )
{
    return true;
}

constexpr bool operator!=(const dimensionless &, const dimensionless & )
{
    return false;
}

/**
 * @brief Multiply @p lhs by @c dimensionless, always return the @p lhs
 * @relates dimensionless
 */
template<class Unit>
constexpr ENGUNITS_ENABLE_IF_T(is_unit_v<Unit>, Unit)
    operator*( const Unit & lhs, const dimensionless &)
{
    return lhs;
}

/**
 * @brief Right multiply @p rhs by @c dimensionless, always return the @p rhs
 * @relates dimensionless
 */
template<class Unit>
constexpr ENGUNITS_ENABLE_IF_T(is_unit_v<Unit>, Unit)
    operator*( const dimensionless &, const Unit & rhs)
{
    return rhs;
}

/**
 * @brief @c dimensionless internal multiplication, return @c dimensionless
 * @relates dimensionless
 */
constexpr dimensionless operator*( const dimensionless &, const dimensionless &)
{
    return dimensionless{};
}

}


#endif //ENGINEERING_UNITS_UNIT_DIMENSIONLESS_HPP
