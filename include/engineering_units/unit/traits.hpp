/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef ENGINEERING_UNITS_UNIT_TRAITS_HPP
#define ENGINEERING_UNITS_UNIT_TRAITS_HPP

#include <ratio>
#include <type_traits>

#include <engineering_units/detail/doxygen.hpp>
#include <engineering_units/detail/void_t.hpp>

namespace engunits
{

/**
 * @brief Tag type for base units.
 *
 * The definition of @c BaseUnit in this library is a bit different from the
 * usual one used in physics.
 * We consider a base unit any unit whose physical quantity is not derived.
 * For instance meters, millimeters and feet are all @c BaseUnit in this context,
 * while newtons, joule etc are not base units because they are equivalent
 * to a combination of base units.
 * 
 * Notice that in general a @c BaseUnit has an associated exponent - 
 * `meter_<2>` is a @c BaseUnit -.
 * 
 * Custom base units can be defined with the @ref ENGUNITS_DEFINE_BASE_UNIT macro.
 * Custom physical quantities can be defined with the @ref ENGUNITS_DEFINE_ROOT_UNIT,
 * which also defines a 'root' base unit for the newly created physical quantity.
 * 
 * @sa derived_unit_tag
 */
struct base_unit_tag {};

/**
 * @brief Tag type for derived units.
 * 
 * Derived units are made of a combination of @c BaseUnit.
 * The generic model for 'anonymous' derived units is the @ref mixed_unit class
 * template. New derived units can be defined with the @ref ENGUNITS_DEFINE_DERIVED_UNIT
 * macro.
 * 
 * @sa base_unit_tag
 */
struct derived_unit_tag {};

/**
 * @brief Query information about a unit
 */
template<class T>
struct unit_traits
{
#ifdef ENGUNITS_DOXYGEN
    
    /**
     * @brief The unit being queried
     */
    typedef T unit;
    
    /**
     * @brief Get the unit @p T, but with unitary exponent
     * 
     * @post @c is_same_base< T, base > is true
     */
    typedef unspecified base;
    
    /**
     * @brief Gets the exponent of @p T
     * 
     * The exponent is always be a specialization of @c std::ratio
     */
    typedef std::ratio<Num, Den> exponent;
    
    /**
     * @brief The unit category.
     * 
     * Only allowed values are @ref base_unit_tag and @ref derived_unit_tag
     */
    typedef unspecified unit_category;
    
    /**
     * @brief Metafunction used to get a new unit with the same base
     * 
     * Returns a new unit that shares the same base as @p T, but with a
     * an exponent defined by @p Num and @p Den
     * 
     * @post @c is_same_base< T, Result > is true
     */
    template<std::intmax_t Num, std::intmax_t Den = 1>
    using base_ = unspecified;
    
    
    /**
     * @brief Get a flat version of @p T
     * 
     * If @p T is a @c BaseUnit, this will return @p T.
     * Otherwise, if @p T is a @c derived_unit, @c flat will return a 
     * @c mixed_list of @c BaseUnit, that is equivalent to @p T
     * 
     * \code{.cpp}
     *  unit_traits< newton >::flat() == mixed_unit< kilogram, meter, second_<-2> >()
     * 
     *  unit_traits< mixed_unit< newton, meter > >::flat() == mixed_unit< kilogram, meter_<2>, second_<-2> >()
     * \endcode
     */
    static constexpr unspecified flat();
    
    /**
     * @brief Get the symbol that represents the unit
     * 
     * Since `string_literal<N>` is not part of the C++ standard yet, we are
     * using a replacement that is an implementation detail. Using the public
     * API you can only assume that he returned type will provided a member 
     * @c c_str function that returns a non-null `const char *`, pointing 
     * to a null-terminating string that represents the symbol
     */
    static constexpr std::string_literal<N> symbol();
    
#endif //ENGUNITS_DOXYGEN
};

// Specialization for base units and derived units.
template< std::intmax_t Num,
          std::intmax_t Den,
          template< std::intmax_t, std::intmax_t > class U >
struct unit_traits< U< Num, Den> >
{
    typedef U<Num, Den> unit;
    typedef typename unit::unit_category unit_category;
    
    typedef U<1,1> base;
    typedef std::ratio<Num, Den> exponent;

    template< std::intmax_t N, std::intmax_t D = 1 >
    using base_ = U<N, D>;

    // Convert derived units into mixed units.
    static constexpr unit flat( base_unit_tag ) { return unit{}; }
    
    static constexpr auto flat( derived_unit_tag ) 
    { 
        return unit::flat();
    }
    
    static constexpr auto flat() 
    {
        return flat( unit_category{} );
    }
    
    static constexpr auto symbol()
    {
        return unit::symbol();
    }
};

#ifdef ENGUNITS_DOXYGEN

/**
 * @brief Check if @p T is a unit
 * @note A @c unit is simply a class type with a member typedef @c unit_tag
 */    
template<class T>
struct is_unit;

#endif // ENGUNITS_DOXYGEN

template<class T, class = void>
struct is_unit : std::false_type {};

template<class T>
struct is_unit<T, detail::void_t< typename unit_traits<T>::unit_category > > :
    std::true_type
{};
    
template<class T>
constexpr bool is_unit_v = is_unit<T>::value;

/**
 * @brief Check if two units have the same base
 * 
 * Metafunction that returns true if @p Lhs and @p Rhs have the same base.
 * 
 * For instance meter and meter squared have the same base (meter), while
 * seconds and kilograms do not.
 * 
 * @pre @c is_unit< @p Lhs > and @c is_unit <@p Rhs > 
 */
template<class Lhs, class Rhs>
using is_same_base = 
    ENGUNITS_UNSPECIFIED(
        typename std::is_same<
            typename unit_traits<Lhs>::base,
            typename unit_traits<Rhs>::base
        >
    );

template<class Lhs, class Rhs>
constexpr bool is_same_base_v = is_same_base<Lhs, Rhs>::value;

/**
 * @brief Special empty type to represent dimensionless results
 */
struct dimensionless {};

/**
 * @brief Compare any unit to @c dimensionless, always false.
 * @relates dimensionless
 */
template<class Unit>
constexpr bool operator==(const Unit &, const dimensionless & )
{
    return false;
}

template<class Unit>
constexpr bool operator!=(const Unit &, const dimensionless & )
{
    return true;
}

/**
 * @brief @c dimensionless vs Unit comparison
 * @relates dimensionless
 */
template<class Unit>
constexpr bool operator==(const dimensionless &, const Unit & )
{
    return false;
}

template<class Rhs>
constexpr bool operator!=(const dimensionless &, const Rhs & )
{
    return true;
}

/**
 * @brief @c dimensionless vs @c dimensionless comparison, always true.
 * @relates dimensionless
 */
constexpr bool operator==(const dimensionless &, const dimensionless & )
{
    return true;
}

constexpr bool operator!=(const dimensionless &, const dimensionless & )
{
    return false;
}

/**
 * @brief Multiply @p lhs by @c dimensionless, always return the @p lhs
 * @relates dimensionless
 */
template<class Unit>
constexpr ENGUNITS_ENABLE_IF_T(is_unit_v<Unit>, Unit)
    operator*( const Unit & lhs, const dimensionless &)
{
    return lhs;
}

/**
 * @brief Right multiply @p rhs by @c dimensionless, always return the @p rhs
 * @relates dimensionless
 */
template<class Unit>
constexpr ENGUNITS_ENABLE_IF_T(is_unit_v<Unit>, Unit)
    operator*( const dimensionless &, const Unit & rhs)
{
    return rhs;
}

/**
 * @brief @c dimensionless internal multiplication, return @c dimensionless
 * @relates dimensionless
 */
constexpr dimensionless operator*( const dimensionless &, const dimensionless &)
{
    return dimensionless{};
}

}


#endif //ENGINEERING_UNITS_UNIT_TRAITS_HPP
