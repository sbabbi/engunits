/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef ENGINEERING_UNITS_UNIT_TRAITS_HPP
#define ENGINEERING_UNITS_UNIT_TRAITS_HPP

#include <ratio>
#include <type_traits>

#include <engineering_units/detail/doxygen.hpp>
#include <engineering_units/detail/void_t.hpp>

namespace engunits
{

/**
 * @brief Tag type for base units.
 * @sa BaseUnit
 */
struct base_unit_tag {};

/**
 * @brief Tag type for derived units.
 * @sa DerivedUnit
 */
struct derived_unit_tag {};

/**
 * @brief Traits to obtain information about a unit
 * @sa BaseUnit, DerivedUnit, base_unit_tag, derived_unit_tag
 */
template<class T>
struct unit_traits
{
#ifdef ENGUNITS_DOXYGEN
    
    /**
     * @brief The unit being queried
     */
    typedef T unit;
    
    /**
     * @brief Get the unit @p T, but with unitary exponent
     * 
     * @post @c is_same_base< T, base > is true
     */
    typedef unspecified base;
    
    /**
     * @brief Gets the exponent of @p T
     * 
     * The exponent is always be a specialization of @c std::ratio
     */
    typedef std::ratio<Num, Den> exponent;
    
    /**
     * @brief The unit category.
     * 
     * Only allowed values are @ref base_unit_tag and @ref derived_unit_tag
     */
    typedef unspecified unit_category;
    
    /**
     * @brief Metafunction used to get a new unit with the same base
     * 
     * Returns a new unit that shares the same base as @p T, but with a
     * an exponent defined by @p Num and @p Den
     * 
     * @post @c is_same_base< T, Result > is true
     */
    template<std::intmax_t Num, std::intmax_t Den = 1>
    using base_ = unspecified;
    
    
    /**
     * @brief Get a flat version of @p T
     * 
     * If @p T is a @c BaseUnit, this will return @p T.
     * Otherwise, if @p T is a @c derived_unit, @c flat will return a 
     * @c mixed_list of @c BaseUnit, that is equivalent to @p T
     * 
     * \code{.cpp}
     *  unit_traits< newton >::flat() == mixed_unit< kilogram, meter, second_<-2> >()
     * 
     *  unit_traits< mixed_unit< newton, meter > >::flat() == mixed_unit< kilogram, meter_<2>, second_<-2> >()
     * \endcode
     */
    static constexpr unspecified flat();
    
    /**
     * @brief Get the symbol that represents the unit
     * 
     * Since `string_literal<N>` is not part of the C++ standard yet, we are
     * using a replacement that is an implementation detail. Using the public
     * API you can only assume that he returned type will provided a member 
     * @c c_str function that returns a non-null `const char *`, pointing 
     * to a null-terminating string that represents the symbol
     */
    static constexpr std::string_literal<N> symbol();
    
#endif //ENGUNITS_DOXYGEN
};

/**
 * @brief Convenience specialization for base and derived units.
 *
 * This specialization applies to all the unit shipped with this library.
 * It looks for class templates in the form `Unit<Num, Den>`.
 * 
 */
template< std::intmax_t Num,
          std::intmax_t Den,
          template< std::intmax_t, std::intmax_t > class U >
struct unit_traits< U< Num, Den> >
{
    typedef U<Num, Den> unit;
    
    typedef U<1,1> base;

    typedef std::ratio<Num, Den> exponent;

    typedef typename unit::unit_category unit_category;

    template< std::intmax_t N, std::intmax_t D = 1 >
    using base_ = U<N, D>;

    static constexpr auto flat() 
    {
        return flat( unit_category{} );
    }
    
    static constexpr auto symbol()
    {
        return unit::symbol();
    }
    
private:
    // Convert derived units into mixed units.
    static constexpr unit flat( base_unit_tag ) { return unit{}; }
    
    static constexpr auto flat( derived_unit_tag ) 
    { 
        return unit::flat();
    }
};

}

#endif //ENGINEERING_UNITS_UNIT_TRAITS_HPP
