/**
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef ENGINEERING_UNITS_UNIT_BASE_CONVERSION_HPP
#define ENGINEERING_UNITS_UNIT_BASE_CONVERSION_HPP

#include <ratio>
#include <type_traits>

#include <engineering_units/unit/traits.hpp>
#include <engineering_units/detail/constexpr_pow.hpp>

namespace engunits
{

namespace detail
{

template<class T> struct always_void
{
    typedef void type;
};
template<class T> using void_t = typename always_void<T>::type;

template<class T, class U, class = void>
struct is_ancestor_of : std::false_type {};

template<class T>
struct is_ancestor_of<T,T> : std::true_type {};

template<class T, class U>
struct is_ancestor_of<
        T,
        U,
        std::enable_if_t<
            !std::is_same<T,U>::value,
            void_t<typename U::parent_unit>
        >
    > : is_ancestor_of<T,typename U::parent_unit> {};

template<class T, class U>
constexpr bool is_ancestor_of_v = is_ancestor_of<T,U>::value;


struct convert_via_lca_tag {};
struct convert_via_ancestor_tag : convert_via_lca_tag {};
struct convert_via_parent_tag : public convert_via_ancestor_tag {};

template<class U>
constexpr auto dispatch_convert_base_unit( const U &,
                                           const U &,
                                           convert_via_parent_tag )
{
    return 1.0L;
}

template<class U>
constexpr auto dispatch_convert_base_unit( const U &,
                                           const typename U::parent_unit &,
                                           convert_via_parent_tag )
{
    return U::to_parent;
}

template<class U>
constexpr auto dispatch_convert_base_unit( const typename U::parent_unit &,
                                           const U &,
                                           convert_via_parent_tag )
{
    return 1.0L / U::to_parent;
}

template<class T, class U>
constexpr auto dispatch_convert_base_unit( const T & t,
                                           const U & u,
                                           convert_via_ancestor_tag,
                                           std::enable_if_t<
                                            is_ancestor_of_v<T,U>,
                                            int
                                           > = 0 )
{
    return dispatch_convert_base_unit( t, typename U::parent_unit {}, convert_via_parent_tag {} ) *
           dispatch_convert_base_unit( typename U::parent_unit {}, u, convert_via_parent_tag {} );
}

template<class T, class U>
constexpr auto dispatch_convert_base_unit( const T & t,
                                           const U & u,
                                           convert_via_ancestor_tag,
                                           std::enable_if_t<
                                            is_ancestor_of_v<U,T>,
                                            int
                                           > = 0 )
{
    return dispatch_convert_base_unit( u, typename T::parent_unit {}, convert_via_parent_tag {} ) *
           dispatch_convert_base_unit( typename T::parent_unit {}, t, convert_via_parent_tag {} );
}

template<class T, class U>
constexpr auto dispatch_convert_base_unit( const T & t,
                                           const U & u,
                                           convert_via_lca_tag )
{
    return dispatch_convert_base_unit( t, typename T::parent_unit {}, convert_via_parent_tag {} ) *
           dispatch_convert_base_unit( typename T::parent_unit {}, typename U::parent_unit {}, convert_via_parent_tag {} ) *
           dispatch_convert_base_unit( typename U::parent_unit {}, u, convert_via_parent_tag {} );
}

template<class T, class U>
constexpr auto convert_base_unit( const T &, const U & )
{
    static_assert(
        std::is_same<
            typename unit_traits<T>::unit_category,
            base_unit_tag
        >::value, "Only base units allowed" );
    
    static_assert(
        std::is_same<
            typename unit_traits<U>::unit_category,
            base_unit_tag
        >::value, "Only base units allowed" );
    
    static_assert(
        std::ratio_equal<
            typename unit_traits<U>::exponent,
            typename unit_traits<T>::exponent
        >::value, "Conversion between units with different exponent" );
    
    static_assert(
        std::is_same<
            typename T::dimension_tag,
            typename U::dimension_tag
        >::value, "Units are not convertible" );
    
    using lhs_base = typename unit_traits<T>::base;
    using rhs_base = typename unit_traits<U>::base;
    using exponent = typename unit_traits<U>::exponent;

    return constexpr_pow(
        dispatch_convert_base_unit( lhs_base{},
                                    rhs_base{},
                                    convert_via_parent_tag{} ),
        exponent::num,
        exponent::den );
}

}
}


#endif //ENGINEERING_UNITS_UNIT_CONVERSION_HPP
